# 🖥️ Real-time document collaboration app

![welcome](public/capture.png)

<code>#Socket.io</code>
<code>#Mongo DB</code>
<code>#Express.js</code>
<code>#React</code>
<code>#Node.js</code>

MERN stack와 Socket.io의 RealTime 통신을 이용하여
실시간으로 텍스트를 같이 편집할 수 있는 웹 어플리케이션입니다.

- 기간: 2023.02.27 - 2023. 03. 01

## Installation

```sh
//frontend
npm install

//backend
npm install

//socket
npm install
```

## Development

```sh
//frontend
npm start // localhost:3000

//backend
npm run dev // localhost:8000

//socket
npm start // localhost:3001
```

## TODO

- [x] 구글을 이용한 소셜 로그인이 되어야 합니다. (Firebase Auth 권장)
- [x] 로그인한 사용자는 새로운 문서를 생성할 수 있습니다.
- [x] 생성된 문서를 저장할 수 있는 기능이 있습니다.
- [x] 저장된 문서는 고유한 URL이 부여됩니다.
- [x] 고유한 문서 URL을 공유하여 다른 사용자들과 협업할 수 있습니다.
- [x] 로그인하지 않은 사용자는 문서 URL에 접근할 수 없습니다. // 해결하기
- [x] 로그인한 사용자는 문서 URL에 접근하여 문서 작업이 가능합니다.
- [x] 문서 작업은 단순 텍스트 입력만 가능하며, 그 외 텍스트의 스타일(굵기, 크기, 폰트) 수
정이나 기타 복잡한 문서작업 기능은 지원하지 않습니다.
- [x] 문서 작업 에디터 구현은 외부 라이브러리 없이 구현해야 합니다.
- [x] 동시에 여러 사용자가 접속하여 동일한 문서에 작업하는 경우, 다른 동시 접속자들의 문
서작업 커서 위치가 사용자에게 표시되어야 합니다. (커서 위치란, 텍스트 타이핑 작업이 이
루어지는 위치입니다.)
- [x] 동시에 동일한 문서에 접속하는 접속자는 최대 2명을 넘지 않는다고 가정합니다.
- [x] 저장된 문서는 매 20초마다 자동저장 되어야 하고, 다시 접속하여 작업할 경우 마지막으
로 저장된 작업 내용을 보여주어야 합니다.
- [x] 로그인한 사용자는 본인이 생성한 문서 목록을 볼 수 있습니다.

<br>

## 🖼 client:
### "/auth/signin" Signin
  - firbase OAuth 기반으로 구글 로그인을 합니다.
  - "/" Main 페이지는 loading 상태가 끝난 후 렌더링 됩니다.


### "/" Main
  - 상단의 헤더에는 새로운 문서를 만들 수 있는 탭 New Docs, 자신이 만든 문서를 볼 수 있는 탭 My Docs 그리고 로그아웃이 있습니다.
  - 헤더에는 로그인한 사용자의 이메일과 이름 그리고 프로필 사진을 표시해줍니다.
  - Main Component의 첫 마운트 시 현재 생성 되어 있는 문서들이 카드형식으로 렌더링 됩니다.
  - Socket을 이용하여 실시간으로 각 문서마다 어떤 유저가 편집중인지 프로필 사진을 통해 보여줍니다.
  - 로그인하지 않은 유저는 새로운 문서 생성, 나의 문서, 개별 문서에 접근할 수 없습니다.

  - 처음 메인페이지 렌더링 시 소켓서버를 연결합니다.
  - 현재 편집 중인 유저의 정보를 소켓서버로부터 받습니다.
  - 받은 정보를 바탕으로 화면에 현재 편집중인 유저와 문서의 id가 일치하는 문서를 찾고 해당하는 문서의 정보를 렌더링합니다.

  - 처음 로그인 시 로그인한 google OAuth의 정보들을 바탕으로 backend 서버에 "POST" 요청을 보냅니다.
  - OAuth의 토큰을 패스워드 같이 여겨 새로운 JWT 토큰을 만들어주는 작업을 합니다.
  - auth.Controller에서는 받은 정보를 바탕으로 user가 있으면 해당 유저를 찾고 없으면 새로운 유저를 생성해 mongoDB에 저장합니다.
  - 받은 토큰을 localStorage에 저장해줍니다.

  - 처음 마운트 시 현재 생성되어 있는 문서들의 정보를 요청합니다. 
  - 현재 URL의 "GET" 요청을 받은 서버는 mongoDB에 저장되어 있는 모든 문서를 전달해줍니다.
  - 받은 문서들을 렌더링 해줍니다.
  <br>

### "/docs/new"
  - 새로운 문서를 생성할 수 있습니다.

  - OAuth를 통해 로그인 되어있는 유저가 없다면 "/" 메인 페이지로 보냅니다.
  - 텍스트 에디터를 컴포넌트로 가지고 있습니다.
  - 텍스트 에디터에 글을 적어주면 useState를 통해 내려준 props인 setContents 를 통해 바뀐 contents를 얻습니다.
  - 저장버튼을 누르면 현재 바뀐 정보들을 스트링화 하여 "POST" 메소드로 server의 포트 + 현재 url 로 보내줍니다.

  - 보내주면서 현재 가지고 있는 토큰이 유효한지 검사하는 작업을 합니다.
  - 서버에서는 토큰을 받으면 verifyToken이란 미들웨어를 통해 토큰의 유효성을 검사한뒤 맞으면 다음 함수를 실행시킵니다.
  - 성공적으로 보내졌다는 결과를 받으면 메인페이지로 보내줍니다.

  - 에러일 경우에는 서버에서 에러메세지를 보내줬으면 에러메세지를 아니면 메세지를 보내줍니다.
<br>

### "/docs/mydocs"
  - 내가 생성한 문서들을 볼 수 있습니다.
  - OAuth를 통해 로그인 되어있는 유저가 없다면 "/" 메인 페이지로 보냅니다.
  - 로그인한 유저의 email을 보내 해당하는 유저가 만든 문서들을 받아옵니다.
  - 그것들을 화면에 뿌려줍니다.
<br>

### "/docs/:id"
  - 문서의 id를 URL로 가진 문서에 접근하여 편집을 할 수 있습니다.
  - 최대 인원의 설정은 2명입니다.
  - 2명이상 편집중일 때 유저가 들어올 시 경고 문구와 함께 메인화면으로 보내집니다.
  - socket의 실시간 기능을 사용하여 자신이 편집한 내용을 같은 url을 가지고 있는 사람들에게 다 보내줬습니다.
  - 20초마다 자동 저장이 됩니다.

  - 첫 마운트 시 db에 저장 되어 있는 정보를 "GET" 메소드를 통해 요청합니다.
  - 이에 맞추 서버에서는 해당하는 url의 id를 id로 가진 문서를 mongoDB에서 찾아내서 문서 객체를 보내줍니다.
  - 받아온 정보들을 렌더링 시킵니다.

  - 텍스트 에디터 컴포넌트에게 `setUpdateContents` 와 `setContents` `contents` `setPhoto` 를 props로 내려줍니다.

  - 내려받은 텍스트 에디터에서 소켓 서버를 연결합니다.
  - `contentEditable`속성을 true로 하여 div를 편집합니다.
  - 편집시마다 handleInput을 사용해 입력된 값에 대한 정보를 `e.target.innerHTML`로 전달받습니다.
  - 받은 정보를 dompurify library를 통해 불순한 정보가 있을 수 있으니 필터링 해줍니다.
  - 받아온 정보에서 키보드 커서를 표시하는 span태그를 제거해줍니다.
  - `setUdateContents` 가 있을 경우 입력된 값을 전달 해줍니다.
  - 여기서 내가 입력한 정보에 대한 키보드 커서의 위치를 window.getSelection으로 얻어내 절대값 좌표로 같이 전달합니다.
  - 바뀐 정보들을 socket 서버의 "edit-content" event에 전달해줍니다.

  - 만약 엔터 키를 누를 경우 라인 브레이크를 통해 다음줄로 보냅니다.

  - 상대방이 입력해줄 경우 `setContentsValue` 를 통해 바뀌는 값들을 전달 받습니다.
  - "recieve-content" 의 event를 통해 상대방이 보낸 값을 전달 받습니다.

  - 바뀐 정보들을 가지고 EditDoc 컴포넌트에서 useCallback을 사용해 submit을 관리합니다.
  - 서브밋이 제출 될 때 updateContents 정보와 title description을 가지고 해당하는 id에게 "POST" 요청으로 보냅니다.
  - 보낼 때 token이 유효한지 한번 더 검사합니다.
  - useCallback을 20초 마다 setInterval을 통해 실행시켜 줍니다.
<br>

### "/*" Not Found
  - page가 없을 경우 Not Found 페이지를 렌더링 합니다.

<br>

## server
  - express로 서버의 포트를 8000으로 지정해준 뒤, 실행하며 mongoose를 통해 mongoDB를 연결해줍니다.
  - auth, main, doc 라우터로 분리하였습니다.
  - 에러 처리의 경우 에러 메세지를 client에게 보내줍니다.
  - cors 이슈를 해결하기 위해 cors library를 실행시켜주었습니다.
<br>

### "auth/signin" auth.controller
  - 성공적으로 로그인할 경우 ok를 보내줍니다.
<br>

### "/" auth.controller
  - 유저같은 경우 각각의 로그인 했던 기록이 있는 유저들의 정보만 기록하였습니다.
  - 클라이언트에서 보낸 "GET" 요청에 대해 현재 mongoDB에 저장되어 있는 문서를 전부 보내줍니다.
  - 받은 유저의 정보를 바탕으로 mongoDB에 저장한 user의 id를 바탕으로 JWT 토큰을 발행합니다.
  - socket서버에서 이용할 저장된 모든 유저의 목록도 보내줍니다.
<br>

### "/doc/new" doc.controller
  - 새로운 문서를 저장할 경우 "POST" 요청으로 보낸 정보들을 바탕으로 Doc Schema 를 통해 스키마를 만들어준 뒤 저장합니다.
<br>

### "/doc/mydocs" doc.controller
  - DOC의 정보에서 user의 email이 일치하는 것들만 필터하여 보내줍니다.
<br>

### "/doc/:id" doc.controller
  - id에 해당하는 정보를 찾아서 보내줍니다.
  - "POST" 요청이 올 경우 해당 id를 찾아 정보를 update 시켜준뒤 다시 보내줍니다.
  - 모든 doc.controller에서 verifyToken을 통해 유효성 검사를 해줍니다.
<br>

## socket
  - 포트를 개별로 사용하여 실행시킵니다.
  - 연결이 될경우 query로 받은 id에 참여합니다.
  - 현재 rooms 라는 객체에 이미 id가 있었을 경우 room을 rooms[id] 속성으로 설정하고 아닐 경우 새로운 set 객체를 만들어줍니다.
  - users의 set객체에 query로 받은 user들의 정보를 넣어줍니다.
  - 현재 id에 들어와있는 user들이 각각 객체에 저장됩니다.
  - 현재 users 객체의 인원이 제한 인원보다 클 경우 "room-full" 이벤트를 통해 가득 찬 것을 알려주고 alert 메세지와 함께 "/" 메인 페이지로 돌려보냅니다.
  - socket에서는 leave를 사용해 떠나게 합니다.

  - 받아온 rooms의 users의 set정보를 배열로 만들기 위해 convertedRooms logic을 이용해 바꿔줍니다.
  - "edit-content" 방에서 받아온 정보를 바탕으로 해당 id와 "receive-content"이벤트에게 받아온 content와 keyboard cursor의 좌표값을 전달해줍니다.
  - 유저들에게 현재 방상태의 정보를 "receive-users" 이벤트를 통해 알려줍니다.

  - 현재 편집중인 유저의 사진 정보를 받아 "receive-photo"에 보내줍니다.

  - 나갈 경우 set에서 유저를 삭제합니다.
  - 현재 접속되어있는 사진 정보도 null로 바꿔 보내줍니다.
<br>

### 질문 목록

- 리액트를 사용하는 이유는 무엇인가요?
- 리덕스를 사용하는 이유는 무엇인가요?
- 가상돔이란 무엇이며, 리액트는 가상돔을 어떻게 이용하나요?
- 상태 불변성이란 무엇인가요?
- 리액트에서 리스트를 렌더링할 때, <code>key</code>라는 prop을 넣어주는 이유는 무엇인가요?
- 리액트 훅의 장점과 단점은 무엇인가요?
- 주소창에 url을 입력했을 때, 페이지가 렌더링 되기까지의 과정은 어떻게 되나요?


### 리액트를 사용하는 이유는 무엇인가요?

- 리액트의 등장 이전에도 jQuery나 Angular와 같은 라이브러리/프레임워크들이 존재했는데 시간이 흐르며 Web App의 크기가 커지며
jQuery로는 효율적으로 관리하기가 어려워져서 조직적인 데이터 관리가 중요해짐이 화두가 됨과 동시에 HTMl CSS JS에서 JS의 중요성이 증대하였고,
- SPA가 등장하게 되면서 이러한 것을 해결할 수 있는 요소로 React등이 성장하게 되었습니다.
- 선언적 API를 제공하여 매번 무엇이 바뀌는 지를 걱정할 필요가 없고 React의 비교 알고리즘인 휴리스틱 알고리즘을 통해 빠르게 바뀐 UI만 업데이트 시켜
렌더링에 있어서 비효율 적인 것들을 줄이고 빠르게 해줍니다.
- 이를 해주기 위한 Virtual DOM을 중간 공간에 두어 상태 변경을 효율적으로 관리해줄 수 있고,
- 컴포넌트 단위의 개발을 하게 됨으로써 재사용과 가독성이 좋아집니다.
- 또한 JSX를 지원함으로서 JS의 확장성을 통해 다양한 표현이 가능해집니다.
- 이처럼 유연하고 빠르게 렌더링을 시킬 수 있는 라이브러리여서 사용한다고 할 수 있습니다.

### 리덕스를 사용하는 이유는 무엇인가요?

- 기존의 React만 사용하는 경우 데이터 규모가 커짐에 따라 props drilling방식으로 상태 관리에 있어 debugging에 애를 먹는 경우가 많이 생기고
- 컴포넌트들이 서로가 서로에게 의존성이 생기게 되면서 재사용을 어렵게 만들기도 합니다.
- 그리고 기존의 데이터를 바꾸는 것이 아닌 새로운 데이터를 생성할 수 있는 상태 불변성을 제공하기 때문에 업데이트에 적합합니다.
- 또한 리듀서가 순수 함수로써 항상 일정한 값을 예측할 수 있어 사용합니다.

### 가상돔이란 무엇이며, 리액트는 가상돔을 어떻게 이용하나요?

- Virtual DOM 이란 DOM을 추상화한 가상의 객체로써 웹사이트가 렌더링 되기 이전에 가상 돔에 안착을 시키고 현재 웹사이트와의 비교를 통해 
다른 부분만 업데이트 할 수 있는 중간다리 역할을 한다고 볼 수 있다.
- 기존의 DOM과 Virtual DOM을 비교할 때 비교 알고리즘이 사용이 되어 빠르고 효율적이게 렌더링이 가능합니다.
### 상태 불변성이란 무엇인가요?

- Javascript에서는 객체들은 참조값을 사용하기 때문에 가변적이다. 이에 리액트에서는 참조값이 동일하면 변경을 감지할 수 없습니다.
- 리액트가 상태값을 업데이트 할 때 얕은 비교를 사용하기 때문에 배열이나 객체를 새로운 참조값을 지닌 것으로 생성하여 상태변화를 감지하게 만듭니다. 
- 또한 원본데이터를 사용하고 있다면 어디에선가 사이드 이펙트가 일어날 수 있기 때문에 이것을 방지하고자 하는 이유도 있습니다. 
### 리액트에서 리스트를 렌더링할 때, <code>key</code>라는 prop을 넣어주는 이유는 무엇인가요?

- 리액트에서는 어떤 항목을 변경, 추가 또는 삭제할 때 key를 이용하여 식별합니다. 
- DOM 노드의 자식들을 재귀적으로 처리할 때 두 리스트를 순회하고 차이점이 있으면 변경을 생성합니다. 예를 들어 자식의 끝에 추가한다면 잘 작동할 것입니다.
- 하지만 순서가 바뀔 경우 자식들 까지 다같이 바꾸는 경우가 생기게 될 수 있습니다. 이를 방지하기 위해 기존의 key값과 비교하여 생성하게 됩니다.
- 또한 index를 key로 사용하면 컴포넌트의 state와 관련된 문제가 발생할 수 있기 때문에 (의도하지 않은 방식으로) 고유한 값을 만드는 것이 좋습니다.

### 리액트 훅의 장점과 단점은 무엇인가요?

- 리액트가 기존에 class로 사용하던 경우 컴포넌트 사이에서 상태 로직을 재사용하기가 어려웠고, 복잡한 컴포넌트들은 이해하기가 어려웠습니다.
- 이에 기존의 알고 있는 class의 개념을 대체하지 않으면서 좀 더 직관적이고 간결하게 코드를 짜는 것이 필요했고 이것이 함수형 컴포넌트에서 훅을 사용함으로써 가능해졌습니다.
- 장점으로는 위의 것들을 포함하여, 상태를 재사용하기가 용이하고 메모리 자원을 덜 소비하고 하나의 코드를 짜기위해 불필요한 수많은 코드들을 제거할 수 있습니다.
- 또한 Custom Hook을 사용할 수 있어 개발의 확장성을 늘려줍니다.
- 단점으로는 호출되는 순서에 의존한 다는 것입니다. 반복문 혹은 조건문 중첩된 함수 내에서 호출할 수 없이 항상 컴포넌트의 바로 하단 최상단에서만 사용해야 한다는 것이 단점입니다.
- 클로져에 의존적이어서 데이터가 늘어나면 이해하기가 어려워질 수 있습니다.

### 주소창에 url을 입력했을 때, 페이지가 렌더링 되기까지의 과정은 어떻게 되나요?

- 클라이언트에서 url이 입력되면 DNS를 통해 IP주소로 변환되게 됩니다. 이는 메모리적인 측면에서 text보다 IP로 변환하게 되면 가져오는 효율적 측면이 높기 때문입니다.
- TCP / IP 통신을 통해 서버에 request 요청을 보냅니다.
- request를 토크나이징 한 후 html파일을 요청하고 서버 컴퓨터로부터 응답을 받아 HTTP를 통해서 파싱된 html 파일과 css등의 정보를 제공받습니다. (DOM TREE)
- 이 때 CSS는 스타일 트리가 되어 DOM TREE와 STYLE TREE를 하나의 RENDER TREE로 묶습니다.
- 그리고 나서 레이아웃 단계를 가져 화면에 어느 위치에 무엇이 그려질지를 표시합니다.
- 레이아웃을 기반으로한 화면에 표시해주고 그려주는 페인트 작업을 실행합니다.
- 레이아웃이 한번 실행된 뒤의 다시한번 더 렌더링이 필요할 때에는 리플로우 작업이 실행됩니다.
- 마찬가지로 리페인트 작업이 실행되면서 렌더를 끝마칩니다.
