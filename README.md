# 🖥️ Real-time document collaboration app

https://vimeo.com/803385801

<code>#Socket.io</code>
<code>#Mongo DB</code>
<code>#Express.js</code>
<code>#React</code>
<code>#Node.js</code>

MERN stack와 Socket.io의 RealTime 통신을 이용하여
실시간으로 텍스트를 같이 편집할 수 있는 웹 어플리케이션입니다.

- 기간: 2023.02.27 - 2023. 03. 01

## Installation

```sh
frontend
npm install

backend
npm install

socket
npm install
```

## Development

```sh
frontend
npm start // localhost:3000

backend
npm run dev // localhost:8000

socket
npm start // localhost:3001
```

## 🎬 Getting Started
<hr>
Local 환경에서 실행시 아래와 같이 준비가 필요합니다.
<br>

  ## client

    REACT_APP_FIREBASE_API_KEY=<Firebase API Key>
    REACT_APP_FIREBASE_AUTO_DOMAIN=<Firebase Auto Domain>
    REACT_APP_FIREBASE_PROJECT_ID=<Firebase Project ID>
    REACT_APP_FIREBASE_STORAGE_BUCKET=<Firebase Storage Bucket>
    REACT_APP_FIREBASE_MESSAGING_SENDER_ID=<Firebase Messaging Sender ID>
    REACT_APP_FIREBASE_APP_ID=<Firebase App ID>
  ## server

    DATABASE_URI=<Mongo DB URI>
    SECRET_KEY=<JWT_Secret Key>

<br>

## TODO
<hr>

- [x] 구글을 이용한 소셜 로그인이 되어야 합니다. (Firebase Auth 권장)
- [x] 로그인한 사용자는 새로운 문서를 생성할 수 있습니다.
- [x] 생성된 문서를 저장할 수 있는 기능이 있습니다.
- [x] 저장된 문서는 고유한 URL이 부여됩니다.
- [x] 고유한 문서 URL을 공유하여 다른 사용자들과 협업할 수 있습니다.
- [x] 로그인하지 않은 사용자는 문서 URL에 접근할 수 없습니다.
- [x] 로그인한 사용자는 문서 URL에 접근하여 문서 작업이 가능합니다.
- [x] 문서 작업은 단순 텍스트 입력만 가능하며, 그 외 텍스트의 스타일(굵기, 크기, 폰트) 수정이나 기타 복잡한 문서작업 기능은 지원하지 않습니다.
- [x] 문서 작업 에디터 구현은 외부 라이브러리 없이 구현해야 합니다.
- [x] 동시에 여러 사용자가 접속하여 동일한 문서에 작업하는 경우, 다른 동시 접속자들의 문서작업 커서 위치가 사용자에게 표시되어야 합니다. (커서 위치란, 텍스트 타이핑 작업이 이루어지는 위치입니다.)
- [x] 동시에 동일한 문서에 접속하는 접속자는 최대 2명을 넘지 않는다고 가정합니다.
- [x] 저장된 문서는 매 20초마다 자동저장 되어야 하고, 다시 접속하여 작업할 경우 마지막으로 저장된 작업 내용을 보여주어야 합니다.
- [x] 로그인한 사용자는 본인이 생성한 문서 목록을 볼 수 있습니다.

<br>

## 🖼 client:
### "/auth/signin" Signin
  - firbase OAuth 기반으로 구글 로그인을 합니다.
  - "/" Main 페이지는 loading 상태가 끝난 후 렌더링 됩니다.


### "/" Main
  - 상단의 헤더에는 새로운 문서를 만들 수 있는 탭 New Docs, 자신이 만든 문서를 볼 수 있는 탭 My Docs 그리고 로그아웃이 있습니다.
  - 헤더에는 로그인한 사용자의 이메일과 이름 그리고 프로필 사진을 표시해줍니다.
  - Main Component의 첫 마운트 시 현재 생성 되어 있는 문서들이 카드형식으로 렌더링 됩니다.
  - Socket을 이용하여 실시간으로 각 문서마다 어떤 유저가 편집중인지 프로필 사진을 통해 보여줍니다.
  - 로그인하지 않은 유저는 새로운 문서 생성, 나의 문서, 개별 문서에 접근할 수 없습니다.

  - 처음 메인페이지 렌더링 시 소켓서버를 연결합니다.
  - 현재 편집 중인 유저의 정보를 소켓서버로부터 받습니다.
  - 받은 정보를 바탕으로 화면에 현재 편집중인 유저와 문서의 id가 일치하는 문서를 찾고 해당하는 문서의 정보를 렌더링합니다.

  - 처음 로그인 시 로그인한 google OAuth의 정보들을 바탕으로 backend 서버에 "POST" 요청을 보냅니다.
  - OAuth의 토큰을 패스워드 같이 여겨 새로운 JWT 토큰을 만들어주는 작업을 합니다.
  - auth.Controller에서는 받은 정보를 바탕으로 user가 있으면 해당 유저를 찾고 없으면 새로운 유저를 생성해 mongoDB에 저장합니다.
  - 받은 토큰을 localStorage에 저장해줍니다.

  - 처음 마운트 시 현재 생성되어 있는 문서들의 정보를 요청합니다.
  - 현재 URL의 "GET" 요청을 받은 서버는 mongoDB에 저장되어 있는 모든 문서를 전달해줍니다.
  - 받은 문서들을 렌더링 해줍니다.
  <br>

### "/docs/new"
  - 새로운 문서를 생성할 수 있습니다.

  - OAuth를 통해 로그인 되어있는 유저가 없다면 "/" 메인 페이지로 보냅니다.
  - 텍스트 에디터를 컴포넌트로 가지고 있습니다.
  - 텍스트 에디터에 글을 적어주면 useState를 통해 내려준 props인 setContents 를 통해 바뀐 contents를 얻습니다.
  - 저장버튼을 누르면 현재 바뀐 정보들을 스트링화 하여 "POST" 메소드로 server의 포트 + 현재 url 로 보내줍니다.

  - 보내주면서 현재 가지고 있는 토큰이 유효한지 검사하는 작업을 합니다.
  - 서버에서는 토큰을 받으면 verifyToken이란 미들웨어를 통해 토큰의 유효성을 검사한뒤 맞으면 다음 함수를 실행시킵니다.
  - 성공적으로 보내졌다는 결과를 받으면 메인페이지로 보내줍니다.

  - 에러일 경우에는 서버에서 에러메세지를 보내줬으면 에러메세지를 아니면 메세지를 보내줍니다.
<br>

### "/docs/mydocs"
  - 내가 생성한 문서들을 볼 수 있습니다.
  - OAuth를 통해 로그인 되어있는 유저가 없다면 "/" 메인 페이지로 보냅니다.
  - 로그인한 유저의 email을 보내 해당하는 유저가 만든 문서들을 받아옵니다.
  - 그것들을 화면에 뿌려줍니다.
<br>

### "/docs/:id"
  - 문서의 id를 URL로 가진 문서에 접근하여 편집을 할 수 있습니다.
  - 최대 인원의 설정은 2명입니다.
  - 2명이상 편집중일 때 유저가 들어올 시 경고 문구와 함께 메인화면으로 보내집니다.
  - socket의 실시간 기능을 사용하여 자신이 편집한 내용을 같은 url을 가지고 있는 사람들에게 다 보내줬습니다.
  - 20초마다 자동 저장이 됩니다.

  - 첫 마운트 시 db에 저장 되어 있는 정보를 "GET" 메소드를 통해 요청합니다.
  - 이에 맞추 서버에서는 해당하는 url의 id를 id로 가진 문서를 mongoDB에서 찾아내서 문서 객체를 보내줍니다.
  - 받아온 정보들을 렌더링 시킵니다.

  - 텍스트 에디터 컴포넌트에게 `setUpdateContents` 와 `setContents` `contents` `setPhoto` 를 props로 내려줍니다.

  - 내려받은 텍스트 에디터에서 소켓 서버를 연결합니다.
  - `contentEditable`속성을 true로 하여 div를 편집합니다.
  - 편집시마다 handleInput을 사용해 입력된 값에 대한 정보를 `e.target.innerHTML`로 전달받습니다.
  - 받은 정보를 dompurify library를 통해 불순한 정보가 있을 수 있으니 필터링 해줍니다.
  - 받아온 정보에서 키보드 커서를 표시하는 span태그를 제거해줍니다.
  - `setUdateContents` 가 있을 경우 입력된 값을 전달 해줍니다.
  - 여기서 내가 입력한 정보에 대한 키보드 커서의 위치를 window.getSelection으로 얻어내 절대값 좌표로 같이 전달합니다.
  - 바뀐 정보들을 socket 서버의 "edit-content" event에 전달해줍니다.

  - 만약 엔터 키를 누를 경우 라인 브레이크를 통해 다음줄로 보냅니다.

  - 상대방이 입력해줄 경우 `setContentsValue` 를 통해 바뀌는 값들을 전달 받습니다.
  - "recieve-content" 의 event를 통해 상대방이 보낸 값을 전달 받습니다.

  - 바뀐 정보들을 가지고 EditDoc 컴포넌트에서 useCallback을 사용해 submit을 관리합니다.
  - 서브밋이 제출 될 때 updateContents 정보와 title description을 가지고 해당하는 id에게 "POST" 요청으로 보냅니다.
  - 보낼 때 token이 유효한지 한번 더 검사합니다.
  - useCallback을 20초 마다 setInterval을 통해 실행시켜 줍니다.
<br>

### "/*" Not Found
  - page가 없을 경우 Not Found 페이지를 렌더링 합니다.

<br>

## 🖥️ server:
  - express로 서버의 포트를 8000으로 지정해준 뒤, 실행하며 mongoose를 통해 mongoDB를 연결해줍니다.
  - auth, main, doc 라우터로 분리하였습니다.
  - 에러 처리의 경우 에러 메세지를 client에게 보내줍니다.
  - cors 이슈를 해결하기 위해 cors library를 실행시켜주었습니다.
<br>

### "auth/signin" auth.controller
  - 성공적으로 로그인할 경우 ok를 보내줍니다.
<br>

### "/" auth.controller
  - 유저같은 경우 각각의 로그인 했던 기록이 있는 유저들의 정보만 기록하였습니다.
  - 클라이언트에서 보낸 "GET" 요청에 대해 현재 mongoDB에 저장되어 있는 문서를 전부 보내줍니다.
  - 받은 유저의 정보를 바탕으로 mongoDB에 저장한 user의 id를 바탕으로 JWT 토큰을 발행합니다.
  - socket서버에서 이용할 저장된 모든 유저의 목록도 보내줍니다.
<br>

### "/doc/new" doc.controller
  - 새로운 문서를 저장할 경우 "POST" 요청으로 보낸 정보들을 바탕으로 Doc Schema 를 통해 스키마를 만들어준 뒤 저장합니다.
<br>

### "/doc/mydocs" doc.controller
  - DOC의 정보에서 user의 email이 일치하는 것들만 필터하여 보내줍니다.
<br>

### "/doc/:id" doc.controller
  - id에 해당하는 정보를 찾아서 보내줍니다.
  - "POST" 요청이 올 경우 해당 id를 찾아 정보를 update 시켜준뒤 다시 보내줍니다.
  - 모든 doc.controller에서 verifyToken을 통해 유효성 검사를 해줍니다.
<br>

## 📡 socket
  - 포트를 개별로 사용하여 실행시킵니다.
  - 연결이 될경우 query로 받은 id에 참여합니다.
  - 현재 rooms 라는 객체에 이미 id가 있었을 경우 room을 rooms[id] 속성으로 설정하고 아닐 경우 새로운 set 객체를 만들어줍니다.
  - users의 set객체에 query로 받은 user들의 정보를 넣어줍니다.
  - 현재 id에 들어와있는 user들이 각각 객체에 저장됩니다.
  - 현재 users 객체의 인원이 제한 인원보다 클 경우 "room-full" 이벤트를 통해 가득 찬 것을 알려주고 alert 메세지와 함께 "/" 메인 페이지로 돌려보냅니다.
  - socket에서는 leave를 사용해 떠나게 합니다.

  - 받아온 rooms의 users의 set정보를 배열로 만들기 위해 convertedRooms logic을 이용해 바꿔줍니다.
  - "edit-content" 방에서 받아온 정보를 바탕으로 해당 id와 "receive-content"이벤트에게 받아온 content와 keyboard cursor의 좌표값을 전달해줍니다.
  - 유저들에게 현재 방상태의 정보를 "receive-users" 이벤트를 통해 알려줍니다.

  - 현재 편집중인 유저의 사진 정보를 받아 "receive-photo"에 보내줍니다.

  - 나갈 경우 set에서 유저를 삭제합니다.
  - 현재 접속되어있는 사진 정보도 null로 바꿔 보내줍니다.
<br>

## 질문 목록
  - 자바스크립트의 Promise를 사용하는 목적은 무엇일까요?
  - 자바스크립트 Garbage Collection의 작동원리에 대해 아는대로 설명해보세요.
  - SSR(Server Side Rendering)과 CSR(Client Side Rendering)의 차이점은 무엇인가요?
  - CORS 정책에 대해 아는대로 설명해보세요.
  - SQL과 NoSQL의 차이점은 무엇인가요?
  - [선택사항] ORM(Object Relation Mapping)과 ODM(Object Document Mapping)은 무엇인가요?
<br>

## 자바스크립트의 Promise를 사용하는 목적은 무엇일까요?
    - 프로그래밍의 맥락에서 비동기 연산은 주 프로그램 흐름과 별도로 실행되는 연산을 의미합니다. 비동기 연산을 사용하면 작업이 완료될 때까지 기다렸다가 다음 작업으로 넘어가는 대신 백그라운드에서 작업이 계속 실행되는 동안 프로그램이 계속 실행될 수 있습니다.

    - 자바스크립트에서 프로미스는 비동기 연산을 처리하고 비동기 연산이 완료된 후 결과 또는 오류를 처리하는 방법을 제공하는 데 사용됩니다.

    - 이를 통해 비동기 작업의 결과를 기다리는 동안 메인 스레드를 차단하지 않는 코드를 작성할 수 있으며, 이는 성능과 사용자 경험에 중요합니다.

    - 또한 프로미스를 사용하면 콜백 기반 비동기 코드에서 발생할 수 있는 문제인 콜백 함수가 깊게 중첩되는 것을 방지하여 더 깔끔하고 유지 관리하기 쉬운 코드를 작성할 수 있습니다. 콜백을 중첩하는 대신 .then() 메서드를 사용하여 프로미스를 서로 연결할 수 있으므로 가독성이 높고 모듈화된 코드를 작성할 수 있습니다.

    - 프로미스의 또 다른 장점은 컴포저블이 가능하며 여러 비동기 연산을 병렬 또는 순서대로 수행하기 위해 함께 결합할 수 있다는 것입니다. 따라서 추론하고 테스트하기 쉬운 복잡한 비동기 코드를 더 쉽게 작성할 수 있습니다.
<br>

## 자바스크립트 Garbage Collection의 작동원리에 대해 아는대로 설명해보세요.
    - 자바스크립트의 가비지 컬렉터는 프로그램에서 더 이상 필요하지 않는 객체가 차지한 메모리를 확보하는 역할을 합니다. 가비지 컬렉터는 더 이상 사용되지 않는 객체를 주기적으로 검사하고 메모리를 제거함으로써 이를 수행합니다.

    - 가비지 컬렉터는 자동으로 주기적으로 실행이 되는데, 가비지 컬렉터는 객체를 저장하는 메모리 영역인 프로그램의 힙을 전역 변수와 같은 글로벌 객체에서부터 추적하여 더 이상 사용되지 않는 객체를 식별하는 프로세스인 마킹을 실행합니다. 가비지 컬렉터가 이러한 마킹을 진행하면 프로그램의 다른 부분에서 사용할 수 있도록 해당 메모리를 회수할 수 있습니다 이를 스윕이라고 합니다.

    - 가비지 컬렉션의 중요한 측면 중 하나는 객체 참조를 관리하는 것입니다. 자바스크립트에서 객체는 메모리에 저장되고 참조를 통해 액세스됩니다. 객체가 더 이상 사용되지 않더라도 여전히 참조되고 있다면 가비지 컬렉션이 불가능합니다. 이는 프로그램이 나중에 해당 객체를 다시 사용해야 할 수도 있기 때문입니다.

    - 가비지 콜렉터는 메모리 사용량을 최적화하기 위해 객체의 유형과 사용 방식에 따라 다른 전략을 사용할 수 있습니다. 예를 들어 자주 사용되는 수명이 짧은 객체는 사용 빈도가 낮은 수명이 긴 객체와 별도의 메모리 공간에 할당될 수 있습니다. 또한 가비지 컬렉터는 휴리스틱을 사용하여 오랫동안 액세스하지 않은 객체나 나머지 프로그램에서 더 이상 접근할 수 없는 객체 등 가비지일 가능성이 있는 객체를 식별할 수 있습니다.

    - 수명이 긴 객체: 일반적으로 한 번 생성되며 애플리케이션의 수명 내내 지속됩니다. 수명이 긴 객체의 예로는 애플리케이션 수준 상태, 전역 구성, 캐시 객체 등이 있습니다. 이러한 객체는 일반적으로 힙에 할당되며, 수명 주기는 특정 함수나 코드 블록에 묶이지 않습니다.

    - 수명이 짧은 객체: 수명이 짧은 객체는 생성 및 소멸 빈도가 더 높으며 일반적으로 함수 수준 범위 또는 로컬 변수와 연관되어 있습니다. 수명이 짧은 객체의 예로는 함수 매개변수, 임시 변수, 함수 내에서 생성 및 소멸되는 객체 속성 등이 있습니다. 이러한 객체는 일반적으로 스택에 할당되며 범위를 벗어나면 가비지 컬렉터에 의해 자동으로 정리됩니다.

    - 전반적으로 자바스크립트의 가비지 컬렉터는 자바스크립트 프로그램에서 메모리 사용량을 관리하는 데 중요한 역할을 합니다. 더 이상 필요하지 않은 메모리를 자동으로 해제함으로써 메모리 누수를 방지하고 프로그램이 복잡해지더라도 효율적으로 실행될 수 있도록 도와줍니다.
<br>

## SSR(Server Side Rendering)과 CSR(Client Side Rendering)의 차이점은 무엇인가요?
    - 서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR)은 웹 페이지를 렌더링하는 두 가지 다른 접근 방식입니다.

    - 서버 사이드 렌더링은 서버에서 웹 페이지의 HTML을 생성하여 클라이언트로 전송하면 클라이언트가 페이지를 표시하는 방식입니다. 서버는 클라이언트가 요청한 데이터를 기반으로 HTML을 생성하고 표시할 준비가 된 전체 페이지를 전송합니다. 이 접근 방식은 단일 페이지 애플리케이션(SPA)이 등장하기 전에는 웹 페이지를 렌더링하는 전통적인 방식이었습니다. 서버 사이드 렌더링은 클라이언트가 즉시 렌더링할 수 있는 완전한 페이지를 수신하므로 일반적으로 초기 페이지 로딩 속도가 빠릅니다. 그러나 서버가 매번 새 페이지를 생성해야 하므로 후속 페이지 로드에서는 속도가 느려질 수 있습니다.

    - 반면 클라이언트 사이드 렌더링은 서버에서 초기 HTML 페이지를 로드한 다음 JavaScript를 사용하여 후속 보기를 렌더링하고 사용자 상호 작용을 처리합니다. 클라이언트 사이드 렌더링을 사용하면 브라우저는 클라이언트 사이드에서 HTML을 생성하는 JavaScript 코드를 다운로드하여 실행합니다. 이 접근 방식은 사용자에게 보다 반응이 빠르고 인터랙티브한 경험을 제공하도록 설계된 최신 단일 페이지 애플리케이션(SPA)에서 사용됩니다. 클라이언트 사이드 렌더링에서는 브라우저가 페이지를 렌더링하기 위해 자바스크립트 코드를 다운로드하고 실행해야 하므로 초기 페이지 로드가 느려질 수 있습니다. 그러나 클라이언트가 전체 서버 응답 없이 페이지를 업데이트할 수 있으므로 후속 페이지 로드는 일반적으로 더 빠릅니다.

    - 빠른 초기 페이지 로드를 위해서 SSR을 사용해 빈 형태의 FORM을 보여주고,  그 후 CSR로 디테일들을 렌더링 하는 식으로 진행할 수 있습니다.

    - 두 접근 방식 모두 장단점이 있으며, 서버 사이드 렌더링과 클라이언트 사이드 렌더링 중 어떤 방식을 선택할지는 애플리케이션의 특정 요구 사항에 따라 달라집니다. 빠른 초기 페이지 로드, SEO 최적화 또는 구형 브라우저 지원이 필요한 애플리케이션의 경우 서버 사이드 렌더링이 더 적합할 수 있습니다. 클라이언트 사이드 렌더링은 고도의 대화형 사용자 경험이 필요하거나 모바일 디바이스를 지원해야 하는 애플리케이션에 더 적합할 수 있습니다.
<br>

## CORS 정책에 대해 아는대로 설명해보세요.
    - CORS(Cross-Origin Resource Sharing)은 도메인이 같을 시, 자원을 공유할 수 있는 정책으로 웹 페이지가 웹 페이지를 제공한 도메인이 아닌 다른 도메인에 정보를 요청하는 것을 방지하기 위해 웹 브라우저에 구현된 보안 기능입니다. 서버가 리소스에 액세스할 수 있는 오리진을 표시하며, 스크립트가 다른 도메인의 리소스에 액세스하지 못하게 합니다.

    - 기본적으로, 브라우저는 스크립트에서 XMLHttpRequest나 fetch를 사용해 다른 도메인의 리소스에 접근할 때, 해당 도메인의 서버가 요청에 대한 응답 헤더에 Access-Control-Allow-Origin 헤더를 포함하도록 요구합니다. 이 헤더는 허용된 출처를 명시하는데, 이를 통해 브라우저는 스크립트에서 접근할 수 있는 출처를 제한할 수 있습니다.

    - 서버는 원본 목록을 지정하거나 와일드카드(*)를 사용하여 모든 원본이 리소스에 액세스하도록 허용할 수 있습니다.

    - 웹 페이지에서 COR을 시도하면 웹 브라우저는 먼저 서버에 preflight 요청을 보내 서버가 요청을 수락할지 여부를 확인합니다. 서버가 요청을 허용하면 브라우저는 실제 요청을 전송합니다.

    - CORS 정책을 우회하기 위해 서버는 프록시를 사용할 수 있는데, 프록시는 클라이언트와 대상 서버 사이에 있는 서버로, 클라이언트의 요청을 대상 서버로 전달할 수 있습니다. 이 프록시가 클라이언트를 대신하여 요청을 수행하거나 클라이언트가 리소스에 액세스할 수 있도록 필요한 헤더를 추가할 수 있습니다. 또는 클라이언트가 JSONP 또는 CORS 지원 API를 사용하여 리소스에 직접 액세스할 수 있습니다.

    - 모든 오리진 허용, 특정 오리진 허용, 오리진 세트 허용 등 다양한 유형의 CORS 정책을 구현할 수 있습니다. 또한 응답에 적절한 헤더를 설정하여 서버 측에서 CORS 정책을 구현할 수도 있습니다.

    - CORS 정책은 악성 스크립트가 다른 도메인의 리소스에 액세스하는 것을 방지하므로 보안상의 이유로 중요합니다. 일반적으로 다른 도메인에서 호스팅되는 API 또는 기타 리소스와 상호 작용하는 웹 애플리케이션에서 사용됩니다.
<br>

## SQL과 NoSQL의 차이점은 무엇인가요?
    - SQL(구조화된 쿼리 언어)과 NoSQL(Not Only SQL)은 데이터를 저장하고 관리하는 접근 방식이 다른 두 가지 유형의 데이터베이스 관리 시스템(DBMS)입니다.

    - SQL 데이터베이스는 관계형 모델을 기반으로 하며 행과 열이 있는 테이블을 사용하여 데이터를 저장합니다. SQL 데이터베이스는 구조화된 데이터를 처리하고 데이터의 구조를 정의하는 엄격한 스키마를 적용하도록 설계되었습니다. SQL 데이터베이스는 데이터를 쿼리하고 조작하기 위해 SQL 언어를 사용합니다. SQL 데이터베이스는 일반적으로 은행 시스템, 전자상거래 플랫폼, 의료 애플리케이션 등 높은 트랜잭션 무결성이 요구되는 애플리케이션에 사용됩니다.

    - 반면에 비관계형 데이터베이스는 비관계형이며 행과 열이 있는 테이블을 사용하여 데이터를 저장하지 않습니다. 대신 NoSQL 데이터베이스는 키-값, 문서, 그래프, 열-패밀리 등 다양한 데이터 모델을 사용합니다. NoSQL 데이터베이스는 비정형 및 반정형 데이터를 처리하도록 설계되었으며 대량의 데이터를 처리하기 위해 수평적으로 확장할 수 있습니다. NoSQL 데이터베이스는 데이터를 쿼리하고 조작하기 위해 다양한 쿼리 언어와 API를 사용합니다. NoSQL 데이터베이스는 일반적으로 소셜 미디어 플랫폼, IoT 애플리케이션, 게임 애플리케이션과 같이 높은 확장성과 유연성이 요구되는 애플리케이션에 사용됩니다.

    - 요약하면 SQL과 NoSQL의 주요 차이점은 다음과 같습니다:
    - 데이터 모델: SQL 데이터베이스는 관계형 모델을 사용하는 반면, NoSQL 데이터베이스는 다양한 비관계형 모델을 사용합니다.
    - 스키마: SQL 데이터베이스는 엄격한 스키마를 적용하는 반면, NoSQL 데이터베이스는 스키마가 없거나 유연한 스키마를 사용합니다.
    - 쿼리 언어: SQL 데이터베이스는 데이터를 쿼리하고 조작하기 위해 SQL을 사용하는 반면, NoSQL 데이터베이스는 다양한 쿼리 - 언어와 API를 사용합니다.
    - 확장성: NoSQL 데이터베이스는 대량의 데이터를 처리하기 위해 수평적으로 확장하도록 설계된 반면, SQL 데이터베이스는 더 강력한 하드웨어를 처리하기 위해 수직적으로 확장하도록 설계되었습니다.
<br>
